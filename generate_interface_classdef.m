function generate_interface_classdef (mexname, varargin)
% generates a template matlab class file based on the macros in the mex
% interface file
%
% Syntax
%
% generate_interface_classdef (mexname)
% generate_interface_classdef (mexname, classname)
%
% Description
%
% generate_interface_classdef creates a template classdef file for use with
% a properly crafted C++ mex interface using handle classes.  The method
% names will be determined from the use of the REGISTER_CLASS_METHOD macro
% in the mex interface file (declared in class_handle.hpp). The new class
% will derive from the cppinterface class (see cppinterface.m).
%
% generate_interface_classdef will only work if you have used the
% convention <classname>_wrapper for your wrapper class. If only one
% argument is provided <classname> will be determined by searching the mex
% interface file for the use of the BEGIN_MEX_CLASS_WRAPPER macro. For
% example if you have a C++ class call MyClass you are creating an
% interface for, you will must have created a class names MyClass_wrapper
% which convers the matlab arguments to appropriate inputs for your C++
% class methods. Then you will have used the macro like so:
%
% BEGIN_MEX_CLASS_WRAPPER(MyClass_wrapper)
%
% generate_interface_classdef will create the new matlab class in
% MyClass.m, or whatever is before the '_wrapper' part of the name. You can
% force generate_interface_classdef to use a different name for the matlab
% class with the optional 'classname' argument.
%
% Similarly the class method names will be generated by examination of the
% use of the REGISTER_CLASS_METHOD macro. For example if your
% MyClass_wrapper class has a method 'doSomething', the macro call might
% look like this:
%
% REGISTER_CLASS_METHOD(MyClass_wrapper,doSomething)
%
% generate_interface_classdef will create a method in the template class
% called 'doSomething' like this:
%
%         function PutForces (self, x)
%             self.cppcall ('PutForces', %\todo: complete PutForces function call args );
%         end
%
% Note you will have to finish the matlab method off yourself with the
% correct arguments to your mex wrapper class.
%
%
% Input
%
%   mexname - fully qualified name of you compiled mex file as it would be
%     called in matlab, e.g. 'mexMyClass', or if it is in a package
%     'mypackage.mexMyClass'. generate_interface_classdef will create the
%     interface class in the same directory as this file.
%
%   classname - optional name for the generated matlab interface class. If
%     not supplied, a name will be extracted from the
%     BEGIN_MEX_CLASS_WRAPPER macro in the file as supplied
%
% 

    options.MClassName = '';
    options.CPPExtension = 'cpp';
    
    options = parse_pv_pairs (options, varargin);
    
    [mexpath,mexfilename,~] = fileparts (which (mexname));
    
    mex_file_loc = fullfile (mexpath, [mexfilename, '.cpp']);
    
    mexclassname = '';
        
    % try to get the wrapper class name from the file
    mexfid = fopen (mex_file_loc, 'r');
    CC2 = onCleanup (@() fclose (mexfid));

    while 1

        tline = fgetl(mexfid);

        if ~ischar(tline), break, end

        % use regular expression to capture the classname
        s = regexp(tline, '\s*BEGIN_MEX_CLASS_WRAPPER\s*\(\s*(?<classname>.*)_wrapper\s*\)', 'names');

        if ~isempty (s)

            mexclassname = s.classname;
            break;

        end

    end

    if isempty (mexclassname)
        error ('mxe wrapper classname could not be determined from mex file macros (should be BEGIN_MEX_CLASS_WRAPPER(<classname>_wrapper).');
    end
    
    if isempty (options.MClassName)
        options.MClassName = mexclassname;
    end

    classdef_file = fullfile (mexpath, [mexclassname, '.m']);
    
    clear CC2; % closes mexfid
    
    interfacefid = fopen (classdef_file, 'w');
    
    CC1 = onCleanup (@() fclose (interfacefid));
    
fprintf (interfacefid, [ ...
... '%% MBCNodal MATLAB/Octave class wrapper to an MBCNodal C++ class\n' ...
'classdef %s < cppinterface\n', ... % classname 
'\n', ...
'    methods\n', ...
'        %% Constructor\n', ...
'        function self = %s ()\n', ... % classname
'\n', ...
'            %% initialise the cppinterface parent class by passing the\n', ...
'            %% mexfunction to the superclass constructor\n', ...
'            self = self@cppinterface(@%s);\n', ... % mexfilename (fully qualified by package etc)
'\n', ...
'        end\n', ...
'\n' ...
], ...
options.MClassName, ... % classname in definition line 
options.MClassName, ... % classname in constructor line 
mexname ... % mexname (fully qualified by package etc)
);

    % attempt to parse the macros from the interface file to get the
    % interface method names
    mexfid = fopen (mex_file_loc, 'r');
    CC2 = onCleanup (@() fclose (mexfid));

    while 1
        
        tline = fgetl(mexfid);
        
        if ~ischar(tline), break, end
        
        % use regular expression to capture the classname
        s = regexp(tline, '\s*REGISTER_CLASS_METHOD\s*\(\s*(?<classname>.*)_wrapper\s*,\s*(?<methodname>.*)\s*\)', 'names');
        
        if ~isempty (s)
            
            write_interface_method (s.methodname, interfacefid);
            
        end
        
    end
    
% finish writing the class wrapper template
fprintf (interfacefid, [ ...  
'    end\n', ...
'\n', ...
'end\n' ] );

end


function write_interface_method (methodname, fid)

fprintf (fid, [ ...
'        function %s (self, x)\n', ...
'            self.cppcall (''%s'', %%\\todo: complete %s function call args );\n', ...
'        end\n\n' ], ...
methodname, methodname, methodname);

end

